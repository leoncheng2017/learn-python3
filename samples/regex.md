[正则表达式](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143193331387014ccd1040c814dee8b2164bb4f064cff000)

- 在正则表达式中，如果直接给出字符，就是精确匹配：

  `\d`可以匹配一个数字

  `\w`可以匹配一个字母或数字

  `.`可以匹配任意字符
  
  由于`'-'`是特殊字符，在正则表达式中，要用`'\'`转义写成`\-`

- 要匹配变长的字符，在正则表达式中：

  `*`表示任意个字符（包括0个）

  `+`表示至少一个字符

  `?`表示0个或1个字符

  `{n}`表示n个字符，

  `{n,m}`表示n-m个字符

  `\s`可以匹配一个空格（也包括Tab等空白符）

- 进阶

  要做更精确地匹配，可以用`[]`表示范围
  
  `A|B`可以匹配A或B
  
  `^`表示行的开头，`^\d`表示必须以数字开头
  
  `$`表示行的结束，`\d$`表示必须以数字结束

- re模块

  Python提供re模块，包含所有正则表达式的功能。由于Python的字符串本身也用`\`转义，强烈建议使用Python的`r`前缀，就不用考虑转义的问题了：

  ```
  s = r'ABC\-001' # Python的字符串
  # 对应的正则表达式字符串不变：
  # 'ABC\-001'
  ```
  ```
  import re
  test = '用户输入的字符串'
  if re.match(r'正则表达式', test):
      print('ok')
  else:
      print('failed')
  ```

- 切分字符串

  ```
  >>> 'a b   c'.split(' ')
  ['a', 'b', '', '', 'c']
  
  >>> re.split(r'\s+', 'a b   c')
  ['a', 'b', 'c']
  
  >>> re.split(r'[\s\,]+', 'a,b, c  d')
  ['a', 'b', 'c', 'd']
  
  >>> re.split(r'[\s\,\;]+', 'a,b;; c  d')
  ['a', 'b', 'c', 'd']
  ```
  如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。

- 分组

  除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用`()`表示的就是要提取的分组（Group）。

  如果正则表达式中定义了组，就可以在`Match`对象上用`group()`方法提取出子串来。

  注意到`group(0)`永远是原始字符串，`group(1)`、`group(2)`……表示第1、2、……个子串。
  ```
  >>> t = '19:05:30'
  >>> m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
  >>> m.groups()
  ('19', '05', '30')
  ```
  这个正则表达式可以直接识别合法的时间。

- 贪婪匹配

  正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。加个`?`就可以让`\d+`采用非贪婪匹配：
  ```
  >>> re.match(r'^(\d+)(0*)$', '102300').groups()
  ('102300', '')
  >>> re.match(r'^(\d+?)(0*)$', '102300').groups()
  ('1023', '00')
  ```

- 编译

  出于效率的考虑可以预编译正则表达式，接下来重复使用时直接匹配
  
